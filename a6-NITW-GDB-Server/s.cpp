#include <stdio.h>
#include <iostream>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/shm.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <semaphore.h>
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int sfd, nsfd, bytesread;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    int PORT = 8080;
    char buffer[1024] = {0};
    // output cpp file generated by the server
    int out = open("p.cpp", O_WRONLY | O_CREAT, 0777);

    // create the socket endpoint
    if ((sfd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
    {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }
    cout<<"Socket created\n";

    // setting the socket options to reuse the address and port if they are already in use
    int opt = 1;
    if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))==-1)
    {
        perror("setsocketopt failed");
        exit(EXIT_FAILURE);
    }

    // setting up the address struct
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // binding the socket to the address
    if (bind(sfd, (struct sockaddr *)&address, sizeof(address)) < 0)
    {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }
    cout<<"Socket binded\n";

    // listening to the socket
    if (listen(sfd, SOMAXCONN) < 0)
    {
        perror("listen failed");
        exit(EXIT_FAILURE);
    }
    cout<<"Socket listening\n";

    // accepting the connection
    if ((nsfd = accept(sfd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0)
    {
        perror("accept failed");
        exit(EXIT_FAILURE);
    }
    cout<<"Received and accepted a connection\n";

    // reading the p.cpp file from the client byte by byte
    char code[16];
    while ((bytesread = read(nsfd, code, 16)) > 0)
    {
        // writing the bytes read to the output file
        write(out, code, bytesread);
        if(bytesread<16){
            break;
        }
    }
    cout<<"\nCode received from the client\n";

    // compiling the received code
    system("g++ p.cpp -o p");

    // creating a runner process to run the received file
    cout<<"Starting the execution of the cpp file\n";
    int runner = fork();
    if (runner == 0)
    {
        // child process that runs the received code
        int itfd = open("IN.txt", O_RDONLY);
        int poutfd = open("Pout.txt", O_WRONLY | O_CREAT, 0777);
        dup2(itfd, 0);
        dup2(poutfd, 1);
        execv("./p", NULL);
    }
    else
    {
        // parent process that waits for the child process to finish
        wait(NULL);
    }

    // read the Pout.txt and OT.txt files
    int poutfd = open("Pout.txt", O_RDONLY);
    int otfd = open("OT.txt", O_RDONLY);
    char expected, actual;

    // read the Pout.txt file byte by byte
    bool passed = true;
    string verdict = "";
    while ((bytesread = read(poutfd, &actual, 1)) > 0)
    {
        // read the OT.txt file byte by byte
        read(otfd, &expected, 1);
        // compare the bytes
        if (expected != actual)
        {
            // if the bytes are not equal, print the error message
            cout << "Error: expected " << expected << " but got " << actual << endl;
            cout << "Test case failed" << endl;
            verdict = "Test case failed";
            send(nsfd, verdict.c_str(), verdict.length(), 0);
            passed = false;
            break;
        }
    }

    // if the test case passed, print the success message
    if (passed)
    {
        verdict = "Test case passed";
        send(nsfd, verdict.c_str(), verdict.length(), 0);
        cout << "Test case passed" << endl;
    }

    // close the file descriptors
    close(poutfd);
    close(otfd);
    close(sfd);
    close(nsfd);

    // cleaning 
    system("rm -rf p c s");

    return 0;
}